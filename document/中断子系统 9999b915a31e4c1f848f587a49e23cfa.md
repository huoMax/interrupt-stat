# 中断子系统

# 概述

本文基于linux-4.17.12

## 中断是什么

中断通常被定义为改变处理器执行指令的顺序的一个事件，该事件与CPU芯片内外部硬件电路产生的电信号相对应。

## 中断的分类

- `同步中断`(synchronous)：又称`异常`（exception），在指令执行时由CPU控制单元产生，之所以称之为同步，是因为只有在一条指令终止执行后CPU才会发出中断。异常通常又可以分为：
    - `错误`（Faults）
    - `陷阱`（Traps）
    - `中止`（Aborts）。
- `异步中断`(asynchronous)：即通常所说的`中断`（interrupt)，由其他硬件设备依照CPU时钟信号随机产生。

## 中断的处理流程

1. 外部设备给中断控制器发送物理中断信号
2. 中断控制器将物理信号转化为中断向量号，发给各个CPU
3. 根据向量号在 IDT 中找到对应的表项，即找到中断向量。CPU将vector乘以16来找到IDT中的条目（32位系统是乘以8）。
4. 进行特权级检查。根据中断描述符表来检查特权等级。
5. 切换堆栈。
- **如果要以较低的数字特权级别执行处理程序过程，则会发生堆栈切换**。从当前执行任务的TSS获得处理程序要使用的堆栈的段选择器和堆栈指针，加载 tss.esp0 到 esp 中， tss.ss0 到 ss 中，从而切换到内核栈。
- 如果要以与被中断过程**相同的特权级别**执行处理程序，则不需要切换堆栈。
1. 压栈
    1. 在 32 位下，会根据有没有特权级切换决定是否压 ss 和 sp：
        1. 如果发生了堆栈切换，堆栈切换后，处理器将原来的EFLAGS、SS、CS、EIP寄存器依次压入**新堆栈**中。如果异常导致保存错误代码（error code），则将其压入EIP值之后的**新堆栈**中。
        2. 若没有特权级的切换，无需进行栈切换，则在原堆栈上进行操作，处理器将EFLAGS，CS和EIP寄存器的当前状态保存在**当前堆栈**中。同样如果异常导致保存错误代码，则将其推入EIP值之后的**当前堆栈**中。
        
        ![Untitled](%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F%209999b915a31e4c1f848f587a49e23cfa/Untitled.png)
        
    2. 在 64 位下无论如何都会压。这样一来，保证了所有中断和异常的栈帧(stackframe)都是一样大的。在 iret 时也不必进行区分，都弹出相同数量的寄存器值。
        1. error code 用于向 handler 传递相关信息（并不是所有异常都有error code ）。比如对于 page fault handler 来说，产生 page fault的原因有几个，需要让handler区别处理，page fault error code 定义如下：
2. 执行handler
    1. 注意的是，为了防止中断重入，interrupt gate 在执行时会清掉 eflags 寄存器的 IF bit，而 trap gate 不会这样做。
3. 返回原来上下文
    1. 要从异常或中断处理程序过程返回，处理程序必须使用IRET（或IRETD）指令。
    2. **如果在调用处理程序过程时发生了堆栈切换，则IRET指令将在返回时切换回被中断过程的堆栈。**
    
    > IRET指令与RET指令相似，不同之处在于它将已保存的标志恢复到EFLAGS寄存器中。 仅当CPL为0时，才恢复EFLAGS寄存器的IOPL字段。仅当CPL小于或等于IOPL时，才更改IF标志。 请参阅英特尔®64和IA 32架构的第3章“指令集参考，A-L”软件开发人员手册，第2A卷，介绍了IRET指令执行的完整操作。
    > 

## 中断初始化

- arch\x86\kernel\head64.c中调用`x86_64_start_kernel`初始化内核，该函数调用`idt_setup_early_handler()`初始化中断描述符表
    
    ```c
    /* linux-4.17.12\arch\x86\kernel\idt.c
     * idt_setup_early_handler - Initializes the idt table with early handlers
     */
    void __init idt_setup_early_handler(void)
    {
    	int i;
    
    	for (i = 0; i < NUM_EXCEPTION_VECTORS; i++)
    		set_intr_gate(i, early_idt_handler_array[i]);
    #ifdef CONFIG_X86_32
    	for ( ; i < NR_VECTORS; i++)
    		set_intr_gate(i, early_ignore_irq);
    #endif
    	load_idt(&idt_descr);
    }
    ```
    
- init/main.c中调用`trap_init()`, 填写IDT描述符构成中断向量表。
    
    ```c
    /* linux-4.17.12\arch\x86\kernel\traps.c
    */
    void __init trap_init(void)
    {
    	/* Init cpu_entry_area before IST entries are set up */
    	setup_cpu_entry_areas();
    
    /* 初始化中断，前32个中断通过枚举类型定义在arch/x86/include/asm/traps.h */
    	idt_setup_traps();
    
    	/*
    	 * Set the IDT descriptor to a fixed read-only location, so that the
    	 * "sidt" instruction will not leak the location of the kernel, and
    	 * to defend the IDT against arbitrary memory write vulnerabilities.
    	 * It will be reloaded in cpu_init() */
    	cea_set_pte(CPU_ENTRY_AREA_RO_IDT_VADDR, __pa_symbol(idt_table),
    		    PAGE_KERNEL_RO);
    	idt_descr.address = CPU_ENTRY_AREA_RO_IDT;
    
    	/*
    	 * Should be a barrier for any external CPU state:
    	 */
    	cpu_init();
    
    	idt_setup_ist_traps();
    
    	x86_init.irqs.trap_init();
    
    	idt_setup_debugidt_traps();
    }
    ```
    
    - `trap_init()`调用`idt_setup_traps()` 初始化中断，前32个中断通过枚举类型定义在`arch/x86/include/asm/traps.h`
        
        ```c
        /* linux-4.17.12\arch\x86\include\asm\traps.h 
         * Interrupts/Exceptions
        */
        enum {
        	X86_TRAP_DE = 0,	/*  0, Divide-by-zero */
        	X86_TRAP_DB,		/*  1, Debug */
        	X86_TRAP_NMI,		/*  2, Non-maskable Interrupt */
        	X86_TRAP_BP,		/*  3, Breakpoint */
        	X86_TRAP_OF,		/*  4, Overflow */
        	X86_TRAP_BR,		/*  5, Bound Range Exceeded */
        	X86_TRAP_UD,		/*  6, Invalid Opcode */
        	X86_TRAP_NM,		/*  7, Device Not Available */
        	X86_TRAP_DF,		/*  8, Double Fault */
        	X86_TRAP_OLD_MF,	/*  9, Coprocessor Segment Overrun */
        	X86_TRAP_TS,		/* 10, Invalid TSS */
        	X86_TRAP_NP,		/* 11, Segment Not Present */
        	X86_TRAP_SS,		/* 12, Stack Segment Fault */
        	X86_TRAP_GP,		/* 13, General Protection Fault */
        	X86_TRAP_PF,		/* 14, Page Fault */
        	X86_TRAP_SPURIOUS,	/* 15, Spurious Interrupt */
        	X86_TRAP_MF,		/* 16, x87 Floating-Point Exception */
        	X86_TRAP_AC,		/* 17, Alignment Check */
        	X86_TRAP_MC,		/* 18, Machine Check */
        	X86_TRAP_XF,		/* 19, SIMD Floating-Point Exception */
        	X86_TRAP_IRET = 32,	/* 32, IRET Exception */
        };
        ```
        
    - `idt_setup_traps()`实际调用`idt_setup_from_table()`，其参数为两个默认中断向量表，值和上面枚举值相同
        
        ```c
        /* linux-4.17.12\arch\x86\kernel\idt.c
         * idt_setup_traps - Initialize the idt table with default traps
         */
        void __init idt_setup_traps(void)
        {
        	idt_setup_from_table(idt_table, def_idts, ARRAY_SIZE(def_idts), true);
        }
        
        /*
         * The exceptions which use Interrupt stacks. They are setup after
         * cpu_init() when the TSS has been initialized.
         */
        static const __initconst struct idt_data ist_idts[] = {
        	ISTG(X86_TRAP_DB,	debug,		DEBUG_STACK),
        	ISTG(X86_TRAP_NMI,	nmi,		NMI_STACK),
        	ISTG(X86_TRAP_DF,	double_fault,	DOUBLEFAULT_STACK),
        #ifdef CONFIG_X86_MCE
        	ISTG(X86_TRAP_MC,	&machine_check,	MCE_STACK),
        #endif
        };
        
        /* 
         * The default IDT entries which are set up in trap_init() before
         * cpu_init() is invoked. Interrupt stacks cannot be used at that point and
         * the traps which use them are reinitialized with IST after cpu_init() has
         * set up TSS.
         */
        static const __initconst struct idt_data def_idts[] = {
        	INTG(X86_TRAP_DE,		divide_error),
        	INTG(X86_TRAP_NMI,		nmi),
        	INTG(X86_TRAP_BR,		bounds),
        	INTG(X86_TRAP_UD,		invalid_op),
        	INTG(X86_TRAP_NM,		device_not_available),
        	INTG(X86_TRAP_OLD_MF,		coprocessor_segment_overrun),
        	INTG(X86_TRAP_TS,		invalid_TSS),
        	INTG(X86_TRAP_NP,		segment_not_present),
        	INTG(X86_TRAP_SS,		stack_segment),
        	INTG(X86_TRAP_GP,		general_protection),
        	INTG(X86_TRAP_SPURIOUS,		spurious_interrupt_bug),
        	INTG(X86_TRAP_MF,		coprocessor_error),
        	INTG(X86_TRAP_AC,		alignment_check),
        	INTG(X86_TRAP_XF,		simd_coprocessor_error),
        
        #ifdef CONFIG_X86_32
        	TSKG(X86_TRAP_DF,		GDT_ENTRY_DOUBLEFAULT_TSS),
        #else
        	INTG(X86_TRAP_DF,		double_fault),
        #endif
        	INTG(X86_TRAP_DB,		debug),
        
        #ifdef CONFIG_X86_MCE
        	INTG(X86_TRAP_MC,		&machine_check),
        #endif
        
        	SYSG(X86_TRAP_OF,		overflow),
        #if defined(CONFIG_IA32_EMULATION)
        	SYSG(IA32_SYSCALL_VECTOR,	entry_INT80_compat),
        #elif defined(CONFIG_X86_32)
        	SYSG(IA32_SYSCALL_VECTOR,	entry_INT80_32),
        #endif
        };
        
        ```
        
- 在`start_kernel()`调用`trap_init()` 之后，还会调用 `init_IRQ()` 来初始化其他的设备中断，最终会调用到 `native_init_IRQ()`。这里面从第 32 个中断开始，到最后 `NR_VECTORS` 为止，对于 `used_vectors` 中没有标记为 1 的位置，都会调用 `set_intr_gate()` 设置中断向量表。`used_vectors` 中没有标记为 1 的，都是设备中断的部分，也即所有的设备中断的中断处理函数在中断向量表里面都会设置为从 `irq_entries_start` 开始，偏移量为 `i - FIRST_EXTERNAL_VECTOR` 的一项。
    
    ```c
    /* linux-4.17.12\arch\x86\kernel\irqinit.c
    */
    void __init init_IRQ(void)
    {
        int i;
        /*
         * On cpu 0, Assign ISA_IRQ_VECTOR(irq) to IRQ 0..15.
         * If these IRQ's are handled by legacy interrupt-controllers like PIC,
         * then this configuration will likely be static after the boot. If
         * these IRQ's are handled by more mordern controllers like IO-APIC,
         * then this vector space can be freed and re-used dynamically as the
         * irq's migrate etc.
         */
        for (i = 0; i < nr_legacy_irqs(); i++)
            per_cpu(vector_irq, 0)[ISA_IRQ_VECTOR(i)] = irq_to_desc(i);
        x86_init.irqs.intr_init();
    }	
    
    .irqs = {
        .pre_vector_init	= init_ISA_irqs,
        .intr_init		= native_init_IRQ,
        .trap_init		= x86_init_noop,
        .intr_mode_init		= apic_intr_mode_init
    },
    
    void __init native_init_IRQ(void)
    {
        /* Execute any quirks before the call gates are initialised: */
        x86_init.irqs.pre_vector_init();
        idt_setup_apic_and_irq_gates();
        lapic_assign_system_vectors();
        if (!acpi_ioapic && !of_ioapic && nr_legacy_irqs())
            setup_irq(2, &irq2);
        irq_ctx_init(smp_processor_id());
    }
    ```
    
- 中断处理函数定义在 `irq_entries_start` 表里，在 `arch\x86\entry\entry_32.S` 和 `arch\x86\entry\entry_64.S` 都能找到这个函数表的定义。这里面定义了 `FIRST_SYSTEM_VECTOR` 到 `FIRST_EXTERNAL_VECTOR` 项。每一项都是中断处理函数，会跳到 `common_interrupt()` 去执行，并最终调用 `do_IRQ()`，调用完毕后，就从中断返回。
    
    ```c
    
    ENTRY(irq_entries_start)
        vector=FIRST_EXTERNAL_VECTOR
        .rept (FIRST_SYSTEM_VECTOR - FIRST_EXTERNAL_VECTOR)
      pushl  $(~vector+0x80)      /* Note: always in signed byte range */
        vector=vector+1
      jmp  common_interrupt /* 会调用到do_IRQ */
      .align  8
        .endr
    END(irq_entries_start)
    
    common_interrupt:
      ASM_CLAC
      addq  $-0x80, (%rsp)      /* Adjust vector to [-256, -1] range */
      interrupt do_IRQ
      /* 0(%rsp): old RSP */
    ret_from_intr:
    ......
      /* Interrupt came from user space */
    GLOBAL(retint_user)
    ......
    /* Returning to kernel space */
    retint_kernel:
    ......
    
    ```
    
- `do_IRQ()`从 AX 寄存器里面拿到了中断向量 vector，但是别忘了中断控制器发送给每个 CPU 的中断向量都是每个 CPU 局部的，而抽象中断处理层的虚拟中断信号 `irq` 以及它对应的中断描述结构 `irq_desc` 是全局的，也即这个 CPU 的 200 号的中断向量和另一个 CPU 的 200 号中断向量对应的虚拟中断信号 `irq` 和中断描述结构 `irq_desc` 可能不一样，这就需要一个映射关系。这个映射关系放在 `Per CPU` 变量 `vector_irq` 里面。
    
    ```c
    /*
     * do_IRQ handles all normal device IRQ's (the special
     * SMP cross-CPU interrupts have their own specific
     * handlers).
     */
    __visible unsigned int __irq_entry do_IRQ(struct pt_regs *regs)
    {
        struct pt_regs *old_regs = set_irq_regs(regs);
        struct irq_desc * desc;
        /* high bit used in ret_from_ code  */
        unsigned vector = ~regs->orig_ax;
    ......
        desc = __this_cpu_read(vector_irq[vector]);
        if (!handle_irq(desc, regs)) {
    ......
      }
    ......
        set_irq_regs(old_regs);
        return 1;
    }
    
    DECLARE_PER_CPU(vector_irq_t, vector_irq);
    
    ```
    
- 在系统初始化的时候，我们会调用 `__assign_irq_vector()`，将虚拟中断信号 `irq` 分配到某个 CPU 上的中断向量。一旦找到某个向量，就调用`irq_to_desc(irq)`将 CPU 此向量对应的向量描述结构 `irq_desc`设置为虚拟中断信号 `irq` 对应的向量描述结构 。 `do_IRQ()` 会根据中断向量 vector 得到对应的 中断`irq`，然后调用 `handle_irq()`。`handle_irq()` 会调用 `generic_handle_irq_desc()`，最终调用 该中断`irq`绑定的处理函数 `handle_irq()`。
    
    ```c
    bool handle_irq(struct irq_desc *desc, struct pt_regs *regs)
    {
    ......
        generic_handle_irq_desc(desc);
    ......
    }
    
    /*
     * Architectures call this to let the generic IRQ layer
     * handle an interrupt.
     */
    static inline void generic_handle_irq_desc(struct irq_desc *desc)
    {
        desc->handle_irq(desc);
    }
    
    ```
    
- `handle_irq()`函数最终会调用`__handle_irq_event_percpu()`，`__handle_irq_event_percpu()` 里面调用了 `irq_desc ()`里每个 `handler`，这些 `handler` 是我们在所有 `action` 列表中注册的，这才是我们设置的那个中断处理函数。如果返回值是 `IRQ_HANDLED`，就说明处理完毕；如果返回值是 `IRQ_WAKE_THREAD` 就唤醒线程。至此，中断的整个过程就结束了。
    
    ```c
    irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc, unsigned int *flags)
    {
        irqreturn_t retval = IRQ_NONE;
        unsigned int irq = desc->irq_data.irq;
        struct irqaction *action;
    
        record_irq_time(desc);
    
        for_each_action_of_desc(desc, action) {
            irqreturn_t res;
            res = action->handler(irq, action->dev_id);
            switch (res) {
            case IRQ_WAKE_THREAD:
                __irq_wake_thread(desc, action);
            case IRQ_HANDLED:
                *flags |= action->flags;
                break;
            default:
                break;
            }
            retval |= res;
        }
        return retval;
    }
    ```
    

# Interrupt controller

中断控制器(Interrupt controller)是一个用于控制中断的硬件，起作用是对每一个经过它的中断源(Interrupt Source 也叫`IRQ`-Interrupt Request)进行优先级判定，同时在多核系统中也可以将某个中断源送入指定的CPU，实现中断的负载均衡。x86的中断控制器称为`APIC`(Advanced Programmable interrupt controller)，arm的中断控制器称为`GIC`(Generic interrupt controller)。

## APIC

APIC由两部分组成：

- Local APIC：
- I/O APIC：

![Untitled](%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F%209999b915a31e4c1f848f587a49e23cfa/Untitled%201.png)

有两种工作方式：

- 8259A模式：禁用Local APIC , APIC直连CPU
- 标准模式：启用Local APIC，所有的中断用过I/O APIC接收之后派发给对应的Local APIC

使用两种APIC的好处：

- CPU的引脚是有限的，不能满足所有外设APIC直连的需求
- 解耦硬件设备和CPU，实现SMP系统中的中断的负载均衡

## Local APIC

Local APIC存在于每个CPU核心中，Local APIC 负责处理特定于 CPU 的中断配置，常被用于管理来自 APIC 时钟（APIC-timer）、热敏元件和其他与 I/O 设备连接的设备的中断。

## irq_chip

irq_chip是linux描述interrupt controller的数据结构，其中提供了一组回调函数指针，用于指向interrupt实际向系统提供的中断控制方法

```c
/* linux-4.17.12\include\linux\irq.h
 * struct irq_chip -----> hardware interrupt controller describe
 * @name: interrupt controller name
 * @irq_startup: 控制器初始化函数
 * @irq_shutdown: 控制器关闭函数
 * @irq_enable: 中断使能函数，使能irq, 通常是调用irq_unmask()，通过irq_data指名irq
 * @irq_disable: 禁止irq, 通常直接调用irq_mask
 * @irq_ack: 用于CPU对该irq的回应，通常表示CPU希望清除该irq的pending状态，准备接受下一个irq请求
 * @irq_mask: 屏蔽irq
 * @irq_mask_ack: 相当于irq_mask() + irq_ack()
 * @irq_unmask: 取消屏蔽指定irq
 * @irq_eoi: 某些中断控制器需要在CPU处理完该irq之后发出eoi信号
 * @irq_set_affinity: 用于设置该irq与CPU之间的亲和力, 就是通知中断控制器, 在irq发生时，哪些CPU有权响应该irq 
 * @irq_retrigger: 
 * @irq_set_type: 设置irq的电气触发条件，比如IRQ_TYPE_LEVEL_HIGH(电平触发) 或IRQ_TYPE_EDGE_RIEING(边缘触发)
 * @irq_set_wake: 通知电源管理子系统，该irq是否可以用作系统的唤醒源
*/
struct irq_chip {
	struct device	*parent_device;
	const char	*name;                                   
	unsigned int	(*irq_startup)(struct irq_data *data);
	void		(*irq_shutdown)(struct irq_data *data);
	void		(*irq_enable)(struct irq_data *data);
	void		(*irq_disable)(struct irq_data *data);

	void		(*irq_ack)(struct irq_data *data);
	void		(*irq_mask)(struct irq_data *data);
	void		(*irq_mask_ack)(struct irq_data *data);
	void		(*irq_unmask)(struct irq_data *data);
	void		(*irq_eoi)(struct irq_data *data);

	int		(*irq_set_affinity)(struct irq_data *data, const struct cpumask *dest, bool force);
	int		(*irq_retrigger)(struct irq_data *data);
	int		(*irq_set_type)(struct irq_data *data, unsigned int flow_type);
	int		(*irq_set_wake)(struct irq_data *data, unsigned int on);

	void		(*irq_bus_lock)(struct irq_data *data);
	void		(*irq_bus_sync_unlock)(struct irq_data *data);

	void		(*irq_cpu_online)(struct irq_data *data);
	void		(*irq_cpu_offline)(struct irq_data *data);

	void		(*irq_suspend)(struct irq_data *data);
	void		(*irq_resume)(struct irq_data *data);
	void		(*irq_pm_shutdown)(struct irq_data *data);

	void		(*irq_calc_mask)(struct irq_data *data);

	void		(*irq_print_chip)(struct irq_data *data, struct seq_file *p);
	int		(*irq_request_resources)(struct irq_data *data);
	void		(*irq_release_resources)(struct irq_data *data);

	void		(*irq_compose_msi_msg)(struct irq_data *data, struct msi_msg *msg);
	void		(*irq_write_msi_msg)(struct irq_data *data, struct msi_msg *msg);

	int		(*irq_get_irqchip_state)(struct irq_data *data, enum irqchip_irq_state which, bool *state);
	int		(*irq_set_irqchip_state)(struct irq_data *data, enum irqchip_irq_state which, bool state);

	int		(*irq_set_vcpu_affinity)(struct irq_data *data, void *vcpu_info);

/* 将CPU间中断ipi(inter-processor interrupt)发送到单个CPU */
	void		(*ipi_send_single)(struct irq_data *data, unsigned int cpu);

/* 将ipi发送到cpumask上的指定的CPU */
	void		(*ipi_send_mask)(struct irq_data *data, const struct cpumask *dest);

	unsigned long	flags;
};
```

# irq_desc

每个interrupt controller可以控制其接入的`IRQ`(从芯片手册可以知道，每个IRQ都有一个对应的编号，叫中断号，即`irq`)，而linux中对应IRQ的数据结构是`irq_desc`

```c
/* linux-4.17.12\include\linux\irqdesc.h
 * struct irq_desc - interrupt descriptor
 * @irq_common_data:	per irq and chip data passed down to chip functions
 * @kstat_irqs:		irq stats per cpu
 * @handle_irq:		highlevel irq-events handler
 * @preflow_handler:	handler called before the flow handler (currently used by sparc)
 * @action:		the irq action chain
 * @status:		status information
 * @core_internal_state__do_not_mess_with_it: core internal status information
 * @depth:		disable-depth, for nested irq_disable() calls 为正值则表示禁用中断，为0表示启用中断
 * @wake_depth:		enable depth, for multiple irq_set_irq_wake() callers
 * @irq_count:		stats field to detect stalled irqs
 * @last_unhandled:	aging timer for unhandled count
 * @irqs_unhandled:	stats field for spurious unhandled interrupts 无法处理的中断计数
 * @threads_handled:	stats field for deferred spurious detection of threaded handlers
 * @threads_handled_last: comparator field for deferred spurious detection of theraded handlers
 * @lock:		locking for SMP
 * @affinity_hint:	hint to user space for preferred irq affinity
 * @affinity_notify:	context for notification of affinity changes
 * @pending_mask:	pending rebalanced interrupts
 * @threads_oneshot:	bitfield to handle shared oneshot threads
 * @threads_active:	number of irqaction threads currently running
 * @wait_for_threads:	wait queue for sync_irq to wait for threaded handlers
 * @nr_actions:		number of installed actions on this descriptor
 * @no_suspend_depth:	number of irqactions on a irq descriptor with
 *			IRQF_NO_SUSPEND set
 * @force_resume_depth:	number of irqactions on a irq descriptor with
 *			IRQF_FORCE_RESUME set
 * @rcu:		rcu head for delayed free
 * @kobj:		kobject used to represent this struct in sysfs
 * @request_mutex:	mutex to protect request/free before locking desc->lock
 * @dir:		/proc/irq/ procfs entry
 * @debugfs_file:	dentry for the debugfs file
 * @name:		flow handler name for /proc/interrupts output
 */
struct irq_desc {
	struct irq_common_data	irq_common_data;
	struct irq_data		irq_data;
	unsigned int __percpu	*kstat_irqs;
	irq_flow_handler_t	handle_irq;
#ifdef CONFIG_IRQ_PREFLOW_FASTEOI
	irq_preflow_handler_t	preflow_handler;
#endif
	struct irqaction	*action;	/* IRQ action list */
	unsigned int		status_use_accessors;
	unsigned int		core_internal_state__do_not_mess_with_it;
	unsigned int		depth;		/* nested irq disables */
	unsigned int		wake_depth;	/* nested wake enables */
	unsigned int		irq_count;	/* For detecting broken IRQs */
	unsigned long		last_unhandled;	/* Aging timer for unhandled count */
	unsigned int		irqs_unhandled;
	atomic_t		threads_handled;
	int			threads_handled_last;
	raw_spinlock_t		lock;
	struct cpumask		*percpu_enabled;
	const struct cpumask	*percpu_affinity;
#ifdef CONFIG_SMP
	const struct cpumask	*affinity_hint;
	struct irq_affinity_notify *affinity_notify;
#ifdef CONFIG_GENERIC_PENDING_IRQ
	cpumask_var_t		pending_mask;
#endif
#endif
	unsigned long		threads_oneshot;
	atomic_t		threads_active;
	wait_queue_head_t       wait_for_threads;
#ifdef CONFIG_PM_SLEEP
	unsigned int		nr_actions;
	unsigned int		no_suspend_depth;
	unsigned int		cond_suspend_depth;
	unsigned int		force_resume_depth;
#endif
#ifdef CONFIG_PROC_FS
	struct proc_dir_entry	*dir;
#endif
#ifdef CONFIG_GENERIC_IRQ_DEBUGFS
	struct dentry		*debugfs_file;
	const char		*dev_name;
#endif
#ifdef CONFIG_SPARSE_IRQ
	struct rcu_head		rcu;
	struct kobject		kobj;
#endif
	struct mutex		request_mutex;
	int			parent_irq;
	struct module		*owner;
	const char		*name;
} ____cacheline_internodealigned_in_smp;
```

## IRQ数组定义

```c
/* linux-4.17.12\include\linux\irqdesc.h
*/
...
extern struct irq_desc irq_desc[NR_IRQS];
```

```c
/* linux-4.17.12\kernel\irq\irqdesc.c
*/
...
struct irq_desc irq_desc[NR_IRQS] __cacheline_aligned_in_smp = {
	[0 ... NR_IRQS-1] = {
		.handle_irq	= handle_bad_irq,                        // 坏的/未知的中断处理程序：输出 IRQ 信息供调试，更新 CPU IRQ 次数计数器，回应 IRQ
		.depth		= 1,                                       // 嵌套深度为1
		.lock		= __RAW_SPIN_LOCK_UNLOCKED(irq_desc->lock),  // 还没有自旋锁
	}
};
```

## 中断使能

### 中断使能单个IRQ

```c
/*
* irq_enable()和irq_disable() 
* 通过写入interrupt controller的一组寄存器来实现，每一个IRQ对应寄存器中不同bit
* 因为是对Interrupt controller层面的控制，所以这个使能控制对挂载在该Interrupt controller上的CPU都有效
*/
```

### 单个IRQ中断使能单个CPU

```c
/*
 * 可以通过irq_desc中的percpu_enable位域设置要使能的CPU，来实现irq_percpu_enable()
*/
```

### 使能单个CPU

```c
/*
 * 使用local_irq_disable()/local_irq_save()函数
 * 以x86为例，这是通过关中断指令"cli"实现的
 * 这种中断关闭只对执行关中断指令的CPU有效，要想直接关闭所有CPU对所有中断的响应，通常是不行的
*/
```

## irq_data

可以看到irq_chip中大部分回调函数都使用irq_data作为参数，其实irq_data就是irq_desc中有关`interrupt controller`的部分单独提取出来的

```c
/* linux-4.17.12\include\linux\irq.h 

*/
struct irq_data {
	u32			mask;
	unsigned int		irq;               // 中断号
	unsigned long		hwirq;             // 硬件中断号
	struct irq_common_data	*common;
	struct irq_chip		*chip;           // irq对应的interrupt controller
	struct irq_domain	*domain;         // hwirq到irq的映射
#ifdef	CONFIG_IRQ_DOMAIN_HIERARCHY
	struct irq_data		*parent_data;
#endif
	void			*chip_data;
};
```

## irqaction

`irqaction`是IRQ注册的中断处理函数`ISR`(Interrupt Source Routine)的数据结构，之所以表示为一个数组而不是一个函数指针，是为了进行中断共享。在早期的处理器中，硬件中断的数目很少，且有些中断号已经被永久分配出去了(比如timer和keyboard)，所以不得不对有限的IRQ中断号进行共享，多个设备的中断处理函数对应一个相同的IRQ。

在一个中断发生时，会依次调用IRQ上的每一个`irqaction`，快速判断是不是本设备发生的中断，每一个handler都会被调用，这主要依靠本设备的中断状态寄存器来实现；在设备从挂接的IRQ上卸载时，会通过dev_id判断是哪一个`irqaction`，从而将其从IRQ的irqaction链表上移除。

```c
/* linux-4.17.12\include\linux\interrupt.h
 * struct irqaction - per interrupt action descriptor
 * @handler:	interrupt handler function
 * @name:	name of the device
 * @dev_id:	cookie to identify the device
 * @percpu_dev_id:	cookie to identify the device
 * @next:	pointer to the next irqaction for shared interrupts
 * @irq:	interrupt number
 * @flags:	flags (see IRQF_* above)
 * @thread_fn:	interrupt handler function for threaded interrupts
 * @thread:	thread pointer for threaded interrupts
 * @secondary:	pointer to secondary irqaction (force threading)
 * @thread_flags:	flags related to @thread
 * @thread_mask:	bitmask for keeping track of @thread activity
 * @dir:	pointer to the proc/irq/NN/name entry
*/
struct irqaction {
	irq_handler_t		handler;        
	void			*dev_id;              
	void __percpu		*percpu_dev_id;
	struct irqaction	*next;
	irq_handler_t		thread_fn;       // 线程的执行函数
	struct task_struct	*thread;     // 执行中断的线程的task_struct
	struct irqaction	*secondary;
	unsigned int		irq;
	unsigned int		flags;
	unsigned long		thread_flags;
	unsigned long		thread_mask;
	const char		*name;
	struct proc_dir_entry	*dir;
} ____cacheline_internodealigned_in_smp;
```

# IDT

## 中断描述符

Intel 给32位操作系统提供了三种类型的中断描述符：`任务门`、`中断门`及`陷阱门`描述符

![Untitled](%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F%209999b915a31e4c1f848f587a49e23cfa/Untitled%202.png)

给64位操作系统提供了16字节的门描述符

![Untitled](%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F%209999b915a31e4c1f848f587a49e23cfa/Untitled%203.png)

但Linux根据DPL将其再细分为五类：`中断门`、`系统门`、`系统中断门`、`陷阱门`、`任务门`

- 中断门(`interrupt gate`)：DPL为0。用户态的进程不能访问，所有的linux中断处理程序都在中断门激活，并限制在内核态
- 陷阱门(`trap gate`)：DPL为0。用户态的进程不能访问，大部分的异常处理程序是通过陷阱门来激活的。
- 任务门(`task gate`)：DPL为0。用户态的进程不能访问，Linux对“Double fualt"异常的处理程序都是通过任务门来激活的。
- 系统门(`system gate`)：DPL为3。用户进程可以访问的陷阱门。通过系统门可以激活三个Linux异常处理程序：4（into）、15（bound）、128（int $0x80）
- 系统中断门(`system interrupt gate`)：DPL为3。用户进程可以访问的中断门。与向量3相关的异常处理程序是通过系统中断门来激活的，因此，在用户态可以使用汇编指令int3

### gate_struct

```c
/* linux-4.17.12\arch\x86\include\asm\desc_defs.h
 * x86 64新增了在原门描述符基础上新增了4字节的offest和4字节的保留位，总计16字节一个门描述符
*/
struct gate_struct {
	u16		offset_low;
	u16		segment;
	struct idt_bits	bits;
	u16		offset_middle;
#ifdef CONFIG_X86_64
	u32		offset_high;
	u32		reserved;
#endif
} __attribute__((packed));

struct idt_bits {
	u16		ist	: 3,
			zero	: 5,
			type	: 5,
			dpl	: 2,
			p	: 1;
} __attribute__((packed));
```

### IDT填充gate_struct

```c
/* linux-4.17.12\arch\x86\include\asm\desc.h
 * 使用pack_gate()填充一个门描述符，然后使用write_idt_entry宏将填充好的gate_struct 拷贝到IDT中去, 
 * write_idt_entry通过调用native_write_idt_entry()来实现
*/
static inline void pack_gate(gate_desc *gate, unsigned type, unsigned long func,
			     unsigned dpl, unsigned ist, unsigned seg)
{
	gate->offset_low	= (u16) func;
	gate->bits.p		= 1;
	gate->bits.dpl		= dpl;
	gate->bits.zero		= 0;
	gate->bits.type		= type;
	gate->offset_middle	= (u16) (func >> 16);
#ifdef CONFIG_X86_64
	gate->segment		= __KERNEL_CS;
	gate->bits.ist		= ist;
	gate->reserved		= 0;
	gate->offset_high	= (u32) (func >> 32);
#else
	gate->segment		= seg;
	gate->bits.ist		= 0;
#endif
}
...

#define write_idt_entry(dt, entry, g)		native_write_idt_entry(dt, entry, g)
...

static inline void native_write_idt_entry(gate_desc *idt, int entry, const gate_desc *gate)
{
	memcpy(&idt[entry], gate, sizeof(*gate));
}
```

## linux中中断向量的定义

```c
/* linux-4.17.12\arch\x86\include\asm\irq_vectors.h
 * Linux IRQ vector layout.
 *
 * There are 256 IDT entries (per CPU - each entry is 8 bytes) which can
 * be defined by Linux. They are used as a jump table by the CPU when a
 * given vector is triggered - by a CPU-external, CPU-internal or
 * software-triggered event.
 *
 * Linux sets the kernel code address each entry jumps to early during
 * bootup, and never changes them. This is the general layout of the
 * IDT entries:
 *
 *  Vectors   0 ...  31 : system traps and exceptions - hardcoded events
 *  Vectors  32 ... 127 : device interrupts
 *  Vector  128         : legacy int80 syscall interface
 *  Vectors 129 ... INVALIDATE_TLB_VECTOR_START-1 except 204 : device interrupts
 *  Vectors INVALIDATE_TLB_VECTOR_START ... 255 : special interrupts
 *
 * 64-bit x86 has per CPU IDT tables, 32-bit has one shared IDT table.
 *
 * This file enumerates the exact layout of them:
 */
#define NMI_VECTOR			0x02
#define MCE_VECTOR			0x12

/*
 * IDT vectors usable for external interrupt sources start at 0x20.
 * (0x80 is the syscall vector, 0x30-0x3f are for ISA)
 */
#define FIRST_EXTERNAL_VECTOR		0x20

/*
 * Reserve the lowest usable vector (and hence lowest priority)  0x20 for
 * triggering cleanup after irq migration. 0x21-0x2f will still be used
 * for device interrupts.
 */
#define IRQ_MOVE_CLEANUP_VECTOR		FIRST_EXTERNAL_VECTOR

#define IA32_SYSCALL_VECTOR		0x80

/*
 * Vectors 0x30-0x3f are used for ISA interrupts.
 *   round up to the next 16-vector boundary
 */
#define ISA_IRQ_VECTOR(irq)		(((FIRST_EXTERNAL_VECTOR + 16) & ~15) + irq)

/*
 * Special IRQ vectors used by the SMP architecture, 0xf0-0xff
 *
 *  some of the following vectors are 'rare', they are merged
 *  into a single vector (CALL_FUNCTION_VECTOR) to save vector space.
 *  TLB, reschedule and local APIC vectors are performance-critical.
 */

...
...
...
/*
 * Size the maximum number of interrupts.
 *
 * If the irq_desc[] array has a sparse layout, we can size things
 * generously - it scales up linearly with the maximum number of CPUs,
 * and the maximum number of IO-APICs, whichever is higher.
 *
 * In other cases we size more conservatively, to not create too large
 * static arrays.
 */

#define NR_IRQS_LEGACY			16

#define CPU_VECTOR_LIMIT		(64 * NR_CPUS)
#define IO_APIC_VECTOR_LIMIT		(32 * MAX_IO_APICS)

#if defined(CONFIG_X86_IO_APIC) && defined(CONFIG_PCI_MSI)
#define NR_IRQS						\
	(CPU_VECTOR_LIMIT > IO_APIC_VECTOR_LIMIT ?	\
		(NR_VECTORS + CPU_VECTOR_LIMIT)  :	\
		(NR_VECTORS + IO_APIC_VECTOR_LIMIT))
#elif defined(CONFIG_X86_IO_APIC)
#define	NR_IRQS				(NR_VECTORS + IO_APIC_VECTOR_LIMIT)
#elif defined(CONFIG_PCI_MSI)
#define NR_IRQS				(NR_VECTORS + CPU_VECTOR_LIMIT)
#else
#define NR_IRQS				NR_IRQS_LEGACY
#endif
```

# irq_domain

中断号可以分为逻辑中断号`irq`和硬件中断号`hwirq`。比如多中断控制器的系统上某个`interrupt controller` 可以管理16个IRQ，那么它给每个IRQ的hwirq即是0~15，当软件收到中断之后，它是不可能通过这个hwirq判断出该中断来自哪个`interrupt controller`，所以需要有一个逻辑中断号`irq`对硬件中断号`hwirq`进行映射，以对不同`interrupt controller`的不同中断进行区分。当然，如果系统中只有一个中断控制器的话，就不用考虑这么多。

```c
/* linux-4.17.12\include\linux\irqdomain.h
 * struct irq_domain - Hardware interrupt number translation object
 * @link: Element in global irq_domain list.
 * @name: Name of interrupt domain
 * @ops: pointer to irq_domain methods
 * @host_data: private data pointer for use by owner.  Not touched by irq_domain
 *             core code.
 * @flags: host per irq_domain flags
 * @mapcount: The number of mapped interrupts
 *
 * Optional elements
 * @fwnode: Pointer to firmware node associated with the irq_domain. Pretty easy
 *          to swap it for the of_node via the irq_domain_get_of_node accessor
 * @gc: Pointer to a list of generic chips. There is a helper function for
 *      setting up one or more generic chips for interrupt controllers
 *      drivers using the generic chip library which uses this pointer.
 * @parent: Pointer to parent irq_domain to support hierarchy irq_domains
 * @debugfs_file: dentry for the domain debugfs file
 *
 * Revmap data, used internally by irq_domain
 * @revmap_direct_max_irq: The largest hwirq that can be set for controllers that
 *                         support direct mapping
 * @revmap_size: Size of the linear map table @linear_revmap[]
 * @revmap_tree: Radix map tree for hwirqs that don't fit in the linear map
 * @linear_revmap: Linear table of hwirq->virq reverse mappings
 */
struct irq_domain {
	struct list_head link;
	const char *name;
	const struct irq_domain_ops *ops;
	void *host_data;
	unsigned int flags;
	unsigned int mapcount;

	/* Optional data */
	struct fwnode_handle *fwnode;
	enum irq_domain_bus_token bus_token;
	struct irq_domain_chip_generic *gc;
#ifdef	CONFIG_IRQ_DOMAIN_HIERARCHY
	struct irq_domain *parent;
#endif
#ifdef CONFIG_GENERIC_IRQ_DEBUGFS
	struct dentry		*debugfs_file;
#endif

	/* reverse map data. The linear map gets appended to the irq_domain */
	irq_hw_number_t hwirq_max;
	unsigned int revmap_direct_max_irq;
	unsigned int revmap_size;
	struct radix_tree_root revmap_tree;
	struct mutex revmap_tree_mutex;
	unsigned int linear_revmap[];
};
```

## 映射组织形式

我们把从虚拟地址到物理地址的转换称为映射(mapping)，把从物理地址到虚拟地址的转换称为逆向映射(reverse mapping)。同样地，将虚拟中断号转换成物理中断号的过程是映射，将物理中断号转换成虚拟中断号的过程则是逆向映射。

CPU使用的是虚拟地址，所以大多数时候我们都是需要通过虚拟地址去获得物理地址，进而真正地访问物理内存，逆向映射一般仅用在内存回收的时候。但在中断处理中，中断是从CPU外部来的，因而首先有的是物理中断号，大多数时候我们要做的是根据映射规则获得虚拟中断号，即逆向映射，这就是`irq_domain`结构体中`revmap`的由来。

对于hwirq到irq的映射方式，linux一般采用三种方式来进行：`radix_tree`、`linear map`、`direct map`，三种方式不会同时存在，只是在`irq_domain`中定义在一起。

### radix_tree map

即采用基树结构进行映射，`hwirq`作为`radix_tree`添加和查找节点的`key`，`irq`作为`value`。在irq_domain中对应的数据结构是`revmap_tree`。在linux中，一般通过系统可能的最大IRQ总数`hwirq_max`来判断使用哪一种数据结构，大于256则使用`radix_tree`，小于256则使用`linear map`。

### linear map

即线性映射，`hwirq`作为线性数组的下标索引，通过`hwirq`和`linear_revmap[]`则可以得到对应的`irq`，在`irq_domain`中对应于`revmap_size`和`linear_revmap[]`元素。使用线性映射方式映射时间固定，但是数组大小也是固定为hwirq_max，可能会造成浪费。

### direct map

我们之所以要进行映射是因为`hwirq`是由物理连线决定的，无法改变，但是像PowerPC架构所使用的`MPIC`(Multi-Processor Interrupt Controller)，其功能很强，可以通过寄存器配置`hwirq`，这样只需要将`hwirq`直接配置成我们所需要的编号就可以了，不再需要映射的过程。此时，不再有物理中断号和虚拟中断号的概念，`irq`直接等于`hwirq`。这个方式对应于irq_domain中的`revmap_direct_max_irq`。

# ISR

# softirq

## softirq种类

## softirq执行

## softirq抢占

# 参考

以上内容都要么是总结下面的参考文章，要么就是照搬原话，先备注下

1. [知乎《中断处理系列》兰新宇](https://zhuanlan.zhihu.com/p/93289632)
2. [博客园《X86中断/异常与APIC》木多](https://www.cnblogs.com/wsg1100/p/14055863.html#1-%E5%BC%82%E5%B8%B8%E5%90%91%E9%87%8F%EF%BC%88vector%EF%BC%89)
3. [blog《Linux操作系统学习笔记（十五）中断》Ty Chen](https://ty-chen.github.io/linux-kernel-interrupt/)